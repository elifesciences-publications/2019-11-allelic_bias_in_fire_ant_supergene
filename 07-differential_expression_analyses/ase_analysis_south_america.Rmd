---
title: "ase_comparison_south_america.Rmd"
author: "Carlos Martinez Ruiz"
date: "20 November 2018"
output: pdf_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
``` 
```{r libraries, echo = FALSE, message = FALSE}
#Load all libraries
library(tximport)
library(readr)
library(DESeq2)
library(GenomicRanges)
library(GenomicFeatures)
library(ggplot2)
library(dplyr)

for (package in (.packages()) ) { 
 print(paste("Package", package, "version", package.version(package)))
}
```

## Introduction

This script will analyse the variant specific expression for the supergene South American populations from *Solenopsis invicta*. The RNAseq data used for this analysis was extracted from three different body parts (abdomen, thorax and head) from virgin alate queens and whole body from workers, all from polygyne colonies. All individuals were genotyped prior to RNA extraction to make sure that they are heterozygote Sb/SB for the social supergene. To obtain the variant-specific reads, the RNAseq reads were aligned to the *S.invicta* reference genome (gnG assembly) and the variant specific read counts obtained by running GATK's ASEreadCounter with a VCF file specific for North American populations. 

## Import variant specific reads into R

The read counts generated by GATK are stored in a csv file, where one of the columns has the read counts for the reference allele (SB) and another one for the alternative (Sb).

```{r load_data_r, message = FALSE}
#Loads the counts by variant generated by GATK. All samples!!
path_to_samples <- "input/south_america_ase/"
ase_files_ar <- grep("csv", list.files(path_to_samples), value = TRUE)
ase_files_ar <- paste(path_to_samples, ase_files_ar, sep="" )

#Add names to the samples
names(ase_files_ar) <- gsub(x = ase_files_ar, pattern = "(.+/)([0-9]+[A-Z]+)(_.+)", "\\2", perl = TRUE)

#Remove samples from colony AR117, which had very low mapping scores
ase_files_ar <- ase_files_ar[-grep(x = ase_files_ar, pattern = "117")]
#ase_files_ar <- ase_files_ar[-grep(x = ase_files_ar, pattern = "28")]
#ase_files_ar <- ase_files_ar[-grep(x = ase_files_ar, pattern = "104")]
ase_files_ar

#Load all the files in R as a single table
ase_ar <- do.call(rbind,lapply(ase_files_ar, read.table, header = TRUE)) 

#The table loaded contains all ase counts for the AR colonies. This includes different castes (W and Q) and different tissues within queens (Head, Thorax and Abdomen). 
#Each file has different lengths since not all individuals have the same variants.
```
## Load variant specific read counts into R

The data loaded into R gives read counts per SNP, rather than per gene. Every SNP needs to be associated to its gene, and the number of read counts per gene averaged across all its SNPs using the median. The position of the genes was taken from the *S.invicta* annotation file (gnG assembly, version GCF_000188075.1). First step, load into R using GRanges the position of all *S.invicta* genes.

```{r load_gene_positions, message = FALSE, warning = FALSE}
#Transforms the table loaded into a GRanges object, readable by GenomicRanges and GenomicFeatures.
#The first two parameters define the chromosome (contig in this case) and the position of the feature (in this case,
# variants). The other parameters are metadata (they could be whatever) in this case, the counts for the
# reference, the alternative allele and total and the sample to which each read belongs.

ase_gr <- GRanges(Rle(ase_ar$contig),
                  IRanges(start = ase_ar$position, width = 1),
                  countRef = ase_ar$refCount,
                  countAlt = ase_ar$altCount,
                  totCount = ase_ar$totalCount,
                  sample = gsub("([0-9]+[A-Z]+)(\\.[0-9]+)", "\\1", rownames(ase_ar)))

#Load the annotation for the gnG assembly of the Solenopsis invicta reference genome.
si_ann <- makeTxDbFromGFF(file = "input/GCF_000188075.1_Si_gnG_genomic.gff",
                          format="gff3")

#Generate a table with the gene names and its position in the reference
gene_ids <- keys(si_ann, "GENEID")
gene_positions <- AnnotationDbi::select(x = si_ann,
                                        keys = gene_ids,
                                        columns = c("GENEID","TXCHROM", "TXSTART", "TXEND"),
                                        keytype = "GENEID")

colnames(gene_positions) <- c("gene","contig", "start", "end")

#Remove the last exon of gene LOC105202834, this gene is misanotated in gnG and it causes mis-assignment of reads
#The number in the gene positions data frame is replaced with the position of the penultimate exon
gene_positions[gene_positions$gene =="LOC105202834", ]$end <- 220646

#Generates a GRanges object. Same as before, but this time the metadata refers to the gene name directly
gene_positions_gr <- GRanges(Rle(gene_positions$contig),
                                   IRanges(start = gene_positions$start,
                                           end   = gene_positions$end),
                                   gene          = gene_positions$gene)
```

We also want to want which of these genes loaded belong to the supergene, for this the regions of the supergene in the gnG assembly need to be loaded into R. GRanges will be then used to overlap the position of the transcripts with that of the supergene.

```{r load_gng_regions, message = FALSE}
#Load the regions for gnG
regions_gng <- read.table("input/gng_regions.tab", header = TRUE)

#Generate a GRanges object from regions_gng
regions_ranges <- GRanges(Rle(regions_gng$scaffold),
                          IRanges(start = regions_gng$start,
                                  end   = regions_gng$end),
                          region        = regions_gng$region)

```

Once the positions have been generated, it is just a matter of overlapping all GRanges objects, to obtain variant specific data per gene for loci in the supergene region.

```{r overlap_granges_objects, message = FALSE, warning = FALSE}

#This function merges both GRanges objects (the one with the allele counts
# and the other with the transcript anf gene names) according to their overlapping positions.
#This returns a GRanges object with the allele counts per transcript.

ase_by_gene <- mergeByOverlaps(ase_gr, gene_positions_gr,
                                     ignore.strand = TRUE)

#Extract Transcript positions and ase counts from ase_by_gene

ase_by_gene_df <- as.data.frame(ase_by_gene)


#Select only relevant fields (keep the position of the variants only, those of the transcripts will yield repetitions for the same gene)

ase_by_gene_df <- subset(x= ase_by_gene_df, select = c("ase_gr.seqnames", "ase_gr.start",
                                                       "ase_gr.countRef", "ase_gr.countAlt",
                                                       "ase_gr.totCount", "ase_gr.sample",
                                                       "gene_positions_gr.gene"))

#Remove duplicates (arising from different transcripts belonging to the same gene):
ase_by_gene_df <- ase_by_gene_df[!duplicated(ase_by_gene_df), ]


#Generate another GRanges object with the information (includes gene position and name)

ase_by_gene_pos_tmp <- GRanges(Rle(ase_by_gene_df$ase_gr.seqnames),
                           IRanges(start = ase_by_gene_df$ase_gr.start,
                                   width = 1),
                           count_ref     = ase_by_gene_df$ase_gr.countRef,
                           count_alt     = ase_by_gene_df$ase_gr.countAlt,
                           countTot      = ase_by_gene_df$ase_gr.totCount,
                           gene          = ase_by_gene_df$gene_positions_gr.gene,
                           sample        = ase_by_gene_df$ase_gr.sample)

#Now, interesct this GRanges object with the recombination positions
regions_ase_tmp <- mergeByOverlaps(ase_by_gene_pos_tmp,
                                   regions_ranges, ignore.strand = TRUE)

#The GRanges object is clunky and contains a lot of information which is redundant and that I don't need.
#This generates a simplified dataframe with only the position, the allele counts and the transcript and gene names.

regions_ase_df <- cbind(as.data.frame(regions_ase_tmp$ase_by_gene_pos_tmp),
                        as.data.frame(regions_ase_tmp$regions_ranges@elementMetadata))


#The position is not needed, so this is an even more simplified version of the final dataframe.

regions_ase_df  <- regions_ase_df[, c("count_ref", "count_alt",
                                      "countTot", "gene",
                                      "sample","region")]

rm(ase_by_gene_pos_tmp)
rm(regions_ase_tmp)
```

Plot the raw reads per SNP to have a crude look at the variant differences in expression.
```{r plot_raw_variant_specific_reads, message = FALSE}

#This is essentially the same dataset in this case
to_plot_ase_Bb <- subset(regions_ase_df, region == "supergene")

to_plot_ase_Bb_ref <- as.data.frame(to_plot_ase_Bb$count_ref)
to_plot_ase_Bb_ref$type <- rep("referenceB", nrow(to_plot_ase_Bb_ref))
colnames(to_plot_ase_Bb_ref) <- c("count", "type")

to_plot_ase_Bb_alt <- as.data.frame(to_plot_ase_Bb$count_alt)
to_plot_ase_Bb_alt$type <- rep("alternativeb", nrow(to_plot_ase_Bb_alt))

colnames(to_plot_ase_Bb_alt) <- c("count", "type")

to_plot_ase_Bb <- rbind(to_plot_ase_Bb_alt, to_plot_ase_Bb_ref)


ggplot(to_plot_ase_Bb, aes(x = type, y = count)) + geom_boxplot() +
  scale_y_log10()
```

Now the data is ready to be prepared for the DESeq2 analysis. In the next step, the counts per SNP will be aggregated per gene, and the read counts per read summarised using the median. That is, if a gene has 3 SNPs, the read counts per variant will be estimated as the median read count per variant of all 3 SNPs.
```{r aggregate_snps, message = FALSE}
#This is essentially the same dataset in this ase, however a gene does get excluded.
#I think this is because they might be on the edges of some of the scaffolds,
#So the SNP may fall within the supergene, but most of the gene must be outside.
#In any case, the gene is present only in 4 samples, so it would be filtered out
#in the next step.
to_analyse <- subset(regions_ase_df, region == "supergene")

#Collapse the read counts per gene (instead of by variant):
to_analyse_agg     <- aggregate(cbind(count_ref, count_alt) ~ gene + sample,
                                data = to_analyse, median)

to_analyse_agg$body_part <-  gsub(x = to_analyse_agg$sample,
                                  pattern = "([0-9]+[BC]?)([A-Z]+)", replacement = "\\2")
#Make sure that all samples have the same genes in the dataframe. The genes selected are present in all samples in at least one tissue:
#Get genes present in all samples for at least one body part
id.table <- table(to_analyse_agg$gene, to_analyse_agg$body_part)
sample_number <- length(unique(to_analyse_agg$sample))
body_part_number <- length(unique(to_analyse_agg$body_part))
genes_to_keep <- filter_all(as.data.frame(id.table),
                            any_vars(. == (sample_number / body_part_number)))
genes_to_keep <- as.data.frame(unique(genes_to_keep$Var1))
colnames(genes_to_keep) <- "gene"

#Loop to add the missing genes per sample while removing genes that are not present in all samples in at least one tissue
all_samples <- unique(to_analyse_agg$sample)
to_analyse_all_genes <- data.frame()
for(sample in all_samples){
  #Subset dataset per sample
  sample_subset <- to_analyse_agg[to_analyse_agg$sample == sample, ]
  #Keep genes common only to all body parts, remove the genes present exclusively in this sample
  sample_subset <- merge(sample_subset, genes_to_keep, all.y = TRUE)
  #Replace NAs generated
  sample_subset$sample[is.na(sample_subset$sample)] <- sample
  sample_subset$body_part[is.na(sample_subset$body_part)] <- unique(sample_subset$body_part)[!is.na(unique(sample_subset$body_part))]
  sample_subset$count_ref[is.na(sample_subset$count_ref)] <- 0
  sample_subset$count_alt[is.na(sample_subset$count_alt)] <- 0
  #Bind with main data frame
  to_analyse_all_genes <- rbind(to_analyse_all_genes, sample_subset) 
}
to_analyse_agg <- to_analyse_all_genes
```

The data needs to be parsed to be used in DESeq2. Only genes which have counts for all individuals are included in downstream analyses.

```{r parse_data_frame, message = FALSE}
#Generate matrix for B read counts:

to_analyse_B <- matrix(data = to_analyse_agg$count_ref, ncol = length(unique(to_analyse_agg$sample)))

colnames(to_analyse_B) <- paste(unique(to_analyse_agg$sample), "_B", sep = "")
rownames(to_analyse_B) <- unique(to_analyse_agg$gene)

#Generate matrix for b read counts:
to_analyse_b <- matrix(data = to_analyse_agg$count_alt,
                       ncol = length(unique(to_analyse_agg$sample)))

colnames(to_analyse_b) <- paste(unique(to_analyse_agg$sample),
                                "_b", sep = "")
rownames(to_analyse_b) <- unique(to_analyse_agg$gene)

#Merge the two matrixes into a single one, get data ready for DESeq2:---------------------------------------------------------------------------

to_analyse_DESeq2_ar <- cbind(to_analyse_b, to_analyse_B)

#Generate colData, include mitochondrial phylogeny data
#AR104=11a
#AR111=7c
#AR112=7c
#AR114=7c
#AR118=9b
#AR28=?
#AR3=10c
#AR43=8b

sample    <- gsub(x = colnames(to_analyse_DESeq2_ar), pattern = "(.+)(_[Bb])", replacement = "\\1")
allele    <- gsub(x = colnames(to_analyse_DESeq2_ar), pattern = "(.+_)([Bb])", replacement = "\\2")
body_part <- gsub(x = sample, pattern = "([0-9]+[BC]?Q?)([A-Z])", replacement = "\\2")
individual <- gsub(x = sample, pattern = "([0-9]+[BC]?[QW])([A-Z])", replacement = "\\1")
colony <- gsub(x = sample, pattern = "([0-9]+)([A-Z]+)", replacement = paste0("AR", "\\1"), perl = TRUE)
colData_ar <- data.frame(sample, allele, body_part, colony, individual)
rownames(colData_ar) <- colnames(to_analyse_DESeq2_ar)

#Make sure the all the data are integers
to_analyse_DESeq2_ar <- round(to_analyse_DESeq2_ar)
```

##DESeq2 analysis

The analysis for the allele specific expression between the SB and Sb variants is performed in DESeq2. Because the variant specific counts that are being compared always come from the same sample (and therefore, the same library), performing normalisation would flatten actual differences. The analysis therefore needs to be performed ensuring that the samples are not normalised (more info here<http://rpubs.com/mikelove/ase>). The first analysis will consider 'colony', 'body_part', 'allele' and the interaction between 'allele:body_part'.

``` {r interaction_allele:body_part, message = FALSE}
#Get the data into DESeq2, get size factors by body part only (or sample?)

dds_ar_interaction <- DESeqDataSetFromMatrix(countData = to_analyse_DESeq2_ar, colData = colData_ar, design = ~ colony + body_part + allele + allele:body_part)
#Perform the analysis replacing the sizeFactors: 
sizeFactors(dds_ar_interaction) <- rep(1, ncol(to_analyse_DESeq2_ar))
#If using test = LRT, deseq2 performs a test for detecting DE loci, using first a likelihood ratio test (ANOVA-like). This test compares the model ~body_part+allele against a
#reduced model, ~body_part. The p values indicate which genes are significantly DE accross ALL levels of allele. Normalisation
#has been done only by boy_part, as ASE data comes always from the same sample. If test is not specified it runs the usual Wald test for the last element in the design formula (body_part:allele)
dds_deg_ar_interaction <- DESeq(dds_ar_interaction, test = "LRT", reduced = ~ colony + body_part + allele, betaPrior = FALSE)

#Get results
res_deg_ar_interaction <- results(dds_deg_ar_interaction)
#How many DEG with interaction?
length(which(res_deg_ar_interaction$padj < 0.05))
#0
```
The interaction effect by body part is non-significant for ANY genes in the supergene. Next model, WITHOUT interaction term, just looking directly at 
the allele effect once the body part and colony effect have been considered

``` {r no_interaction, message = FALSE, warning = FALSE}
dds_ar <- DESeqDataSetFromMatrix(countData = to_analyse_DESeq2_ar, colData = colData_ar, design = ~ colony + body_part + allele)
#Perform the analysis replacing the sizeFactors: 
sizeFactors(dds_ar) <- rep(1, ncol(to_analyse_DESeq2_ar))
#Perform DESeq analysis
dds_deg_ar <- DESeq(dds_ar, betaPrior = TRUE)

#Save the DESeq2 object
save(dds_deg_ar, file = "results/dds_Sb_vs_SB_south_america.RData")

#Get results
res_deg_ar <- results(dds_deg_ar)

#Create a 'transparent' black color:
trans_black <- adjustcolor("black", alpha.f = 0.2)

par(mar = c(5, 4.6, 4, 2) + 0.1, mfrow = c(1,1))
plotMA(res_deg_ar, alpha = 0.05,  ylim= c(-8, 8), xlab = "Mean of normalized counts", colNonSig = trans_black,
       ylab = "Logarithm Fold Change", font.lab = 2, cex.axis = 2, cex.lab = 2, cex.main = 2.5, cex = 1.5)
```

##Enrichment analyses

Is there a biase towards SB? To check for this, we should expect the median of the ASE LFCs to be significantly positive. THat, is to find more highly expressed genes in SB than in Sb in general.

```{r median_test, message = FALSE}
median(res_deg_ar$log2FoldChange)
wilcox.test(res_deg_ar$log2FoldChange)
```

Additional tests to check for enrichment: Binomial test for significantly DE genes, and chi squared tests for DE genes in SB and Sb.

```{r enrichment_tests, message = FALSE}
#How many DE genes in total?
de_ase_ar <- length(which(res_deg_ar$padj < 0.05))
#12

#How many in each variant?
de_ase_ar_lb <- length(which(res_deg_ar$padj < 0.05 & res_deg_ar$log2FoldChange < 0))
#6
de_ase_ar_bb <- length(which(res_deg_ar$padj < 0.05 & res_deg_ar$log2FoldChange > 0))
#6

#Total genes in the supergene region:


#Chi2 to check wether any of the variants in enriched

to_test_chi           <- matrix(c(de_ase_ar_lb, de_ase_ar - de_ase_ar_lb, de_ase_ar_bb,
                                  de_ase_ar - de_ase_ar_bb), nrow = 2, ncol = 2)
colnames(to_test_chi) <- c("Bb", "BB")
rownames(to_test_chi) <- c("Over-expresed", "Non-DE")

chisq.test(to_test_chi)
```

##Variant specific vs body part comparisons

Different body parts will perform different functions, and this is reflected in gene expression differences. If most genes in the supergene region perform different functions related to social form, the expectation would be that the SB to Sb differences across body parts should change, as we would expect tissues in the head to be performing differently to those in the abdomen. We already know that there is no Sb-Sb, body part interaction from the previous test, but plotting the SB-Sb differences across tissues will help visualise this result.

``` {r plot_allele:body_part_interaction, message = FALSE}
#Get coefficients for interactions only
dds_ar_coef <- DESeqDataSetFromMatrix(countData = to_analyse_DESeq2_ar, colData = colData_ar, design = ~ colony + body_part + allele:body_part)
#Perform the analysis replacing the sizeFactors: 
sizeFactors(dds_ar_coef) <- rep(1, ncol(to_analyse_DESeq2_ar))
dds_deg_ar_coef <- DESeq(dds_ar_coef, betaPrior = FALSE)
res_deg_ar_coef <- results(dds_deg_ar_coef)

coef_QA <- coefficients(dds_deg_ar_coef)[, "body_partA.alleleB"]
coef_QT <- coefficients(dds_deg_ar_coef)[, "body_partT.alleleB"]
coef_QH <- coefficients(dds_deg_ar_coef)[, "body_partH.alleleB"]
coef_W  <- coefficients(dds_deg_ar_coef)[, "body_partW.alleleB"]

#Plot weihting points by read count mean, add line with linear regression, weighted by counts
#Weight for the point size, by log(mean counts per gene), scaled up to fit 0-1 range
cex_weights <- (log(res_deg_ar_coef$baseMean) - min(log(res_deg_ar_coef$baseMean)))/
  (max(log(res_deg_ar_coef$baseMean))-min(log(res_deg_ar_coef$baseMean)))
par(mfrow = c(3, 2), cex.lab = 2, cex.axis = 2)
plot(coef_QA, coef_QT, type = "n", xlab = "Queen Abdomen LFCs", ylab = "Queen Thorax LFCs")
points(coef_QA, coef_QT, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_QT ~ coef_QA, weights = res_deg_ar_coef$baseMean), col = "red")

plot(coef_QA, coef_QH, type = "n", xlab = "Queen Abdomen LFCs", ylab = "Queen Head LFCs")
points(coef_QA, coef_QH, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_QH ~ coef_QA, weights = res_deg_ar_coef$baseMean), col = "red")

plot(coef_QA, coef_W, type = "n", xlab = "Queen Abdomen LFCs", ylab = "Worker LFCs")
points(coef_QA, coef_W, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_W ~ coef_QA, weights = res_deg_ar_coef$baseMean), col = "red")

plot(coef_QH, coef_W, type = "n", xlab = "Queen Head LFCs", ylab = "Worker LFCs")
points(coef_QH, coef_W, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_W ~ coef_QH, weights = res_deg_ar_coef$baseMean), col = "red")

plot(coef_QT, coef_W, type = "n", xlab = "Queen Thorax LFCs", ylab = "Worker LFCs")
points(coef_QT, coef_W, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_W ~ coef_QT, weights = res_deg_ar_coef$baseMean), col = "red")

plot(coef_QT, coef_QH, type = "n", xlab = "Queen Thorax LFCs", ylab = "Queen Head LFCs")
points(coef_QT, coef_QA, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_QA ~ coef_QT, weights = res_deg_ar_coef$baseMean), col = "red")
par(mfrow = c(1,1))
```

##Variant specific data vs social form comparisons

It has been established that the SB alleles tend to be more highly expressed than their Sb counterparts. But of the few genes whose Sb allele is more highly expressed, are those genes also more highly expressed in general in polygyne queens? To test for this, the results from the comparison between social forms needs to be loaded into R again.

```{r load_morandin_results, message = FALSE}
load("input/2019-01-08_results_deseq2_queens_mor.RData")
load("input/2019-01-08_results_deseq2_workers_mor.RData")
```

Next, a dataset with both comparisons needs to be prepared, ensuring that all the genes are the same in both datasets and are in the same order.

```{r merge_morandin_ase, message = FALSE}

#Genes names equivalent in the Morandin data
genes_morandin <- rownames(res_de_txi_q)

#Get LFCs for each comparison, making sure that all genes are in the same order
lfcs_morandin           <- data.frame(res_de_txi_q[rownames(res_de_txi_q) %in% rownames(res_deg_ar), ])
lfcs_morandin$gene      <- rownames(res_de_txi_q[rownames(res_de_txi_q) %in% rownames(res_deg_ar), ])
lfcs_morandin$gene      <- as.factor(lfcs_morandin$gene)
lfcs_morandin           <- data.frame(lfcs_morandin$gene, lfcs_morandin$log2FoldChange, lfcs_morandin$padj, stringsAsFactors = FALSE)
colnames(lfcs_morandin) <- c("gene", "lfcs_mor", "padj_mor")

lfcs_ase           <- data.frame(res_deg_ar[rownames(res_deg_ar) %in% lfcs_morandin$gene, ])
lfcs_ase$gene      <- rownames(res_deg_ar[rownames(res_deg_ar) %in% lfcs_morandin$gene, ])
lfcs_ase$gene      <- as.factor(lfcs_ase$gene)
lfcs_ase           <- data.frame(lfcs_ase$gene, lfcs_ase$log2FoldChange, lfcs_ase$padj)
colnames(lfcs_ase) <- c("gene", "lfcs_ase", "padj_ase")

#Make sure everything has the same order
lfcs_ase   <- lfcs_ase[order(lfcs_ase$gene), ]
lfcs_morandin <- lfcs_morandin[order(lfcs_morandin$gene), ]
if (!identical(lfcs_ase$gene, lfcs_morandin$gene)) {
  warning("The genes are not the same in both dataframes!")
}
```

Plot the LFCs for both comparisons. This plot shows the LFCs for the comparisons between social forms in queens (from the Morandin et al., 2016 dataset) in the x axis and the LFCs for the comparisons between the SB and Sb variants in polygyne queens (from the Wurm et al., 2011 dataset) in the y axis. The plot also shows the genes which are significantly differentially expressed (according to DESeq2) between social forms only (light blue dots), between variants only (green dots) or in both comparisons (purple dots).

```{r plot_morandin_ase_comparison, message = FALSE}
#Get a colour vector for all values based on the significance of the padj
lfcs_joint <- data.frame(cbind(lfcs_ase, lfcs_morandin), stringsAsFactors = FALSE)


lfcs_joint$cols <- trans_black
lfcs_joint$cols[lfcs_joint$padj_ase < 0.05 & lfcs_joint$padj_mor >= 0.05] <- "#009E73"
lfcs_joint$cols[lfcs_joint$padj_ase >= 0.05 & lfcs_joint$padj_mor < 0.05] <- "#9ad0f3"
lfcs_joint$cols[lfcs_joint$padj_ase < 0.05 & lfcs_joint$padj_mor < 0.05] <- "#CC79A7"


#Plot the thing(and save in png):
#png("DC_sinvicta_2016-17 / 05-0216-CD-analyses / ase_plot.png",
#    width = 10.6, height = 6.3, units = "in", res = 800)
par(mfrow = c(1, 1), mar = c(5, 4.6, 4, 2) + 0.1)
plot(lfcs_morandin$lfcs_mor, lfcs_ase$lfcs_ase, xlab = "Single vs Multiple",
     ylab = "b vs B", xlim = c(-7, 7), font.lab = 2, cex.axis = 2, cex.lab = 2,
     cex.main = 2.5, pch = 16, col = lfcs_joint$cols)
legend("bottomleft", legend = c("No DEG", "DEG variants", "DEG both", "DEG social form"),
       fill = unique(lfcs_joint$cols))
abline(h = 0, col = "red", lwd = 4)
abline(v = 0, col = "red", lwd = 4)
```

Test for enrichment in Sb for polygyne biased genes, via a chi squared test, and by comparing the LFCs distributions across variants in highly and lowly expressed genes in polygyne queens through a Kolmogorov-Smirnov test. The plot of the distributions can be generated by un-commenting lines 417 to 424.

```{r test_morandin_ase_comparison, message = FALSE, warning = FALSE}
####Compare the ASE distributions across a Mono vs Poly gradient
###### Select the Morandin LFCs from 2 sections of the dataset
#Get rid of the NAs first
lfcs_joint_nona <- lfcs_joint[!is.na(lfcs_joint$lfcs_mor), ]
#Sort the new dataset by morandin LFCs
lfcs_joint_mor_sorted <- lfcs_joint_nona[order(lfcs_joint_nona$lfcs_mor), ]

#Using only two halves (M vs P)
lfcs_joint_mor_sorted$mor_halves <- NA

lfcs_joint_mor_sorted$mor_halves[1:round((1 / 2 * nrow(lfcs_joint_mor_sorted)))] <- "HiM"
lfcs_joint_mor_sorted$mor_halves[(round(1 / 2 * nrow(lfcs_joint_mor_sorted)) + 1):nrow(lfcs_joint_mor_sorted)] <- "HiP"
#lfcs_joint_mor_sorted$mor_halves[lfcs_joint_mor_sorted$lfcs_mor < 0] <- "HiM"
#lfcs_joint_mor_sorted$mor_halves[lfcs_joint_mor_sorted$lfcs_mor > 0] <- "HiP"

#Now it's just a matter of comparing the B vs b distributions of LFCs between quarters
ggplot(lfcs_joint_mor_sorted, aes(x = lfcs_ase, fill = mor_halves)) + geom_density(alpha = 0.3) + theme_bw() +
  labs(x = "Logarithm fold change between variants", y = "Density") +
  theme(panel.border = element_blank(), panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) +
  theme(axis.title.x = element_text(face = "bold", size = 30),
        axis.text.x  = element_text(angle = 90, vjust = 0.5, size = 25)) +
  theme(axis.title.y = element_text(face = "bold", size = 30),
        axis.text.y  = element_text(angle = 90, vjust = 0.5, size = 25))

#Kolmogorov-Smirnov tests between quarters to see how different the distributions are
ks.test(lfcs_joint_mor_sorted$lfcs_ase[lfcs_joint_mor_sorted$mor_halves == "HiM"],
        lfcs_joint_mor_sorted$lfcs_ase[lfcs_joint_mor_sorted$mor_halves == "HiP"])

#Compare medians using Mann Whitney
wilcox.test(lfcs_joint_mor_sorted$lfcs_ase[lfcs_joint_mor_sorted$mor_halves == "HiM"],
            lfcs_joint_mor_sorted$lfcs_ase[lfcs_joint_mor_sorted$mor_halves == "HiP"])

#From all Sb over-expressed genes, what is the proportion of polygyne genes? Is it different in SB?
#You need to use the clean df without NAs in the Morandin LFCs. NA in the Morandin LFCs indicate
#that the count for that gene was 0 for Morandin but not for the 2011 queen data, it is thus
#an incongruence and those genes should be removed.

#Total over-expressed genes in Sb
tot_lb <- length(which(lfcs_joint_mor_sorted$lfcs_ase < 0 & lfcs_joint_mor_sorted$padj_ase < 0.05))
#Polygyne biased genes in Sb
pol_lb <- length(which(lfcs_joint_mor_sorted$lfcs_ase < 0 & lfcs_joint_mor_sorted$padj_ase < 0.05 &
                         lfcs_joint_mor_sorted$lfcs_mor > 0 & lfcs_joint_mor_sorted$padj_mor < 0.05))

#Total over-expressed genes in SB
tot_bb <- length(which(lfcs_joint_mor_sorted$lfcs_ase > 0 & lfcs_joint_mor_sorted$padj_ase < 0.05))
#Polygyne biased genes in SB
pol_bb <- length(which(lfcs_joint_mor_sorted$lfcs_ase > 0 & lfcs_joint_mor_sorted$padj_ase < 0.05 &
                         lfcs_joint_mor_sorted$lfcs_mor > 0 & lfcs_joint_mor_sorted$padj_mor < 0.05))

#Chi2 test

to_test_chi_sb           <- matrix(c(pol_lb, tot_lb, pol_bb, tot_bb), nrow = 2, ncol = 2)
colnames(to_test_chi_sb) <- c("Sb", "SB")
rownames(to_test_chi_sb) <- c("Polygyne_only", "Total")

chisq.test(to_test_chi_sb)

#Try with Fisher test
fisher.test(to_test_chi_sb)
```

## Plot all significant genes to check variant effect visually

DESeq2 gives a lsit of differentially expressed genes between variants. Some of those are based on very low read counts on average. The following plot can be use to assess visually those differences.

```{r variant_differences_plot, message = FALSE}

#Select significant genes
sig_genes <- rownames(res_deg_ar[which(res_deg_ar$padj < 0.05), ])
counts_specific_genes <- counts(dds_ar, norm = TRUE)[sig_genes, ]


specific_genes <- rep(rownames(counts_specific_genes), ncol(counts_specific_genes))
samples <- rep(colnames(counts_specific_genes), each = nrow(counts_specific_genes))
variant <- gsub(pattern = ".+_", replacement = "", x = samples)
body_part_sp <- gsub(x = samples, pattern = "([0-9]+[BC]?Q?)([A-Z])(_[Bb])", replacement = "\\2")

specific_genes_parsed <- data.frame(c(counts_specific_genes), specific_genes, samples, variant, body_part_sp)

colnames(specific_genes_parsed) <- c("counts", "genes", "samples", "variant", "body_part")

ggplot(data = specific_genes_parsed, aes(x = variant, y = log(counts + 1), fill = body_part)) + geom_violin() + facet_grid(. ~ genes) +
  geom_jitter(position = position_dodge(1))

```

