---
title: "ase_comparison_south_america.Rmd"
author: "Carlos Martinez Ruiz"
date: "20 de noviembre de 2018"
output: pdf_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
``` 
```{r libraries, echo = FALSE, message = FALSE}
#Load all libraries
library(tximport)
library(readr)
library(DESeq2)
library(GenomicRanges)
library(GenomicFeatures)
library(ggplot2)

for (package in (.packages()) ) { 
 print(paste("Package", package, "version", package.version(package)))
}
```

## Introduction

This script will analyse the variant specific expression for the supergene South American populations from *Solenopsis invicta*. The RNAseq data used for this analysis was extracted from three different body parts (abdomen, thorax and head) from virgin alate queens and whole body from workers, all from polygyne colonies. All individuals were genotyped prior to RNA extraction to make sure that they are heterozygote Sb/SB for the social supergene. To obtain the variant-specific reads, the RNAseq reads were aligned to the *S.invicta* reference genome (gnG assembly) and the variant specific read counts obtained by running GATK's ASEreadCounter with a VCF file specific for North American populations. 

## Import variant specific reads into R

The read counts generated by GATK are stored in a csv file, where one of the columns has the read counts for the reference allele (SB) and another one for the alternative (Sb).

```{r load_data_r, message = FALSE}
#Loads the counts by variant generated by GATK. All samples!!
path_to_samples <- "input/south_america_ase/"
ase_files_ar <- grep("csv", list.files(path_to_samples), value = TRUE)
ase_files_ar <- paste(path_to_samples, ase_files_ar, sep="" )

#Add names to the samples
names(ase_files_ar) <- gsub(x = ase_files_ar, pattern = "(.+/)([0-9]+[A-Z]+)(_.+)", "\\2", perl = TRUE)

#Remove samples from colony AR117, which had very low mapping scores
ase_files_ar <- ase_files_ar[-grep(x = ase_files_ar, pattern = "117")]
#ase_files_ar <- ase_files_ar[-grep(x = ase_files_ar, pattern = "28")]
#ase_files_ar <- ase_files_ar[-grep(x = ase_files_ar, pattern = "104")]
ase_files_ar

#Load all the files in R as a single table
ase_ar <- do.call(rbind,lapply(ase_files_ar, read.table, header = TRUE)) 

#The table loaded contains all ase counts for the AR colonies. This includes different castes (W and Q) and different tissues within queens (Head, Thorax and Abdomen). 
#Each file has different lengths since not all individuals have the same variants.
```
## Load variant specific read counts into R

The data loaded into R gives read counts per SNP, rather than per gene. Every SNP needs to be associated to its gene, and the number of read counts per gene averaged across all its SNPs using the median. The position of the genes was taken from the *S.invicta* annotation file (gnG assembly, version GCF_000188075.1). First step, load into R using GRanges the position of all *S.invicta* genes.

```{r load_gene_positions, message = FALSE, warning = FALSE}
#Transforms the table loaded into a GRanges object, readable by GenomicRanges and GenomicFeatures.
#The first two parameters define the chromosome (contig in this case) and the position of the feature (in this case,
# variants). The other parameters are metadata (they could be whatever) in this case, the counts for the
# reference, the alternative allele and total and the sample to which each read belongs.

ase_gr <- GRanges(Rle(ase_ar$contig),
                  IRanges(start = ase_ar$position, width = 1),
                  countRef = ase_ar$refCount,
                  countAlt = ase_ar$altCount,
                  totCount = ase_ar$totalCount,
                  sample = gsub("([0-9]+[A-Z]+)(\\.[0-9]+)", "\\1", rownames(ase_ar)))

#Load the annotation for the gnG assembly of the Solenopsis invicta reference genome.
si_ann <- makeTxDbFromGFF(file = "input/GCF_000188075.1_Si_gnG_genomic.gff",
                          format="gff3")

#Generate a table with the gene names and its position in the reference
gene_ids <- keys(si_ann, "GENEID")
gene_positions <- select(x = si_ann,
                        keys = gene_ids,
                        columns = c("GENEID","TXCHROM", "TXSTART", "TXEND"),
                        keytype = "GENEID")

colnames(gene_positions) <- c("gene","contig", "start", "end")

#Generates a GRanges object. Same as before, but this time the metadata refers to the gene name directly
gene_positions_gr <- GRanges(Rle(gene_positions$contig),
                                   IRanges(start = gene_positions$start,
                                           end   = gene_positions$end),
                                   gene          = gene_positions$gene)
```

We also want to want which of these genes loaded belong to the supergene, for this the regions of the supergene in the gnG assembly need to be loaded into R. GRanges will be then used to overlap the position of the transcripts with that of the supergene.

```{r load_gng_regions, message = FALSE}
#Load the regions for gnG
regions_gng <- read.table("input/gng_regions.tab", header = TRUE)

#Generate a GRanges object from regions_gng
regions_ranges <- GRanges(Rle(regions_gng$scaffold),
                          IRanges(start = regions_gng$start,
                                  end   = regions_gng$end),
                          region        = regions_gng$region)

```

Once the positions have been generated, it is just a matter of overlapping all GRanges objects, to obtain variant specific data per gene for loci in the supergene region.

```{r overlap_granges_objects, message = FALSE}

#This function merges both GRanges objects (the one with the allele counts
# and the other with the transcript anf gene names) according to their overlapping positions.
#This returns a GRanges object with the allele counts per transcript.

ase_by_gene <- mergeByOverlaps(ase_gr, gene_positions_gr,
                                     ignore.strand = TRUE)

#Extract Transcript positions and ase counts from ase_by_gene

ase_by_gene_df <- as.data.frame(ase_by_gene)


#Select only relevant fields (keep the position of the variants only, those of the transcripts will yield repetitions for the same gene)

ase_by_gene_df <- subset(x= ase_by_gene_df, select = c("ase_gr.seqnames", "ase_gr.start",
                                                       "ase_gr.countRef", "ase_gr.countAlt",
                                                       "ase_gr.totCount", "ase_gr.sample",
                                                       "gene_positions_gr.gene"))

#Remove duplicates (arising from different transcripts belonging to the same gene):
ase_by_gene_df <- ase_by_gene_df[!duplicated(ase_by_gene_df), ]


#Generate another GRanges object with the information (includes gene position and name)

ase_by_gene_pos_tmp <- GRanges(Rle(ase_by_gene_df$ase_gr.seqnames),
                           IRanges(start = ase_by_gene_df$ase_gr.start,
                                   width = 1),
                           count_ref     = ase_by_gene_df$ase_gr.countRef,
                           count_alt     = ase_by_gene_df$ase_gr.countAlt,
                           countTot      = ase_by_gene_df$ase_gr.totCount,
                           gene          = ase_by_gene_df$gene_positions_gr.gene,
                           sample        = ase_by_gene_df$ase_gr.sample)

#Now, interesct this GRanges object with the recombination positions
regions_ase_tmp <- mergeByOverlaps(ase_by_gene_pos_tmp,
                                   regions_ranges, ignore.strand = TRUE)

#The GRanges object is clunky and contains a lot of information which is redundant and that I don't need.
#This generates a simplified dataframe with only the position, the allele counts and the transcript and gene names.

regions_ase_df <- cbind(as.data.frame(regions_ase_tmp$ase_by_gene_pos),
                        as.data.frame(regions_ase_tmp$regions_ranges@elementMetadata))


#The position is not needed, so this is an even more simplified version of the final dataframe.

regions_ase_df  <- regions_ase_df[, c("count_ref", "count_alt",
                                      "countTot", "gene",
                                      "sample","region")]

rm(ase_by_gene_pos_tmp)
rm(regions_ase_tmp)
```

Plot the raw reads per SNP to have a crude look at the variant differences in expression.
```{r plot_raw_variant_specific_reads, message = FALSE}

#This is essentially the same dataset in this case
to_plot_ase_Bb <- subset(regions_ase_df, region == "supergene")

to_plot_ase_Bb_ref <- as.data.frame(to_plot_ase_Bb$count_ref)
to_plot_ase_Bb_ref$type <- rep("referenceB", nrow(to_plot_ase_Bb_ref))
colnames(to_plot_ase_Bb_ref) <- c("count", "type")

to_plot_ase_Bb_alt <- as.data.frame(to_plot_ase_Bb$count_alt)
to_plot_ase_Bb_alt$type <- rep("alternativeb", nrow(to_plot_ase_Bb_alt))

colnames(to_plot_ase_Bb_alt) <- c("count", "type")

to_plot_ase_Bb <- rbind(to_plot_ase_Bb_alt, to_plot_ase_Bb_ref)


ggplot(to_plot_ase_Bb, aes(x = type, y = count)) + geom_boxplot() +
  scale_y_log10()
```

Now the data is ready to be prepared for the DESeq2 analysis. In the next step, the counts per SNP will be aggregated per gene, and the read counts per read summarised using the median. That is, if a gene has 3 SNPs, the read counts per variant will be estimated as the median read count per variant of all 3 SNPs.
```{r aggregate_snps, message = FALSE}
#This is essentially the same dataset in this ase, however a gene does get excluded.
#I think this is because they might be on the edges of some of the scaffolds,
#So the SNP may fall within the supergene, but most of the gene must be outside.
#In any case, the gene is present only in 4 samples, so it would be filtered out
#in the next step.
to_analyse <- subset(regions_ase_df, region == "supergene")

#Collapse the read counts per gene (instead of by variant):
to_analyse_agg     <- aggregate(cbind(count_ref, count_alt) ~ gene + sample,
                                data = to_analyse, median)

#Make sure that all samples have the same genes in the dataframe (some samples have genes that are not on other samples):
id.table <- table(to_analyse_agg$gene)
sample_number <- length(unique(to_analyse_agg$sample))
to_analyse_agg <- subset(to_analyse_agg,
                         gene %in% names(id.table[id.table == sample_number]))
```

The data needs to be parsed to be used in DESeq2. Only genes which have counts for all individuals are included in downstream analyses.

```{r parse_data_frame, message = FALSE}
#Generate matrix for B read counts:

to_analyse_B <- matrix(data = to_analyse_agg$count_ref, ncol = length(unique(to_analyse_agg$sample)))

colnames(to_analyse_B) <- paste(unique(to_analyse_agg$sample), "_B", sep = "")
rownames(to_analyse_B) <- unique(to_analyse_agg$gene)

#Generate matrix for b read counts:
to_analyse_b <- matrix(data = to_analyse_agg$count_alt,
                       ncol = length(unique(to_analyse_agg$sample)))

colnames(to_analyse_b) <- paste(unique(to_analyse_agg$sample),
                                "_b", sep = "")
rownames(to_analyse_b) <- unique(to_analyse_agg$gene)

#Merge the two matrixes into a single one, get data ready for DESeq2:---------------------------------------------------------------------------

to_analyse_DESeq2_ar <- cbind(to_analyse_b, to_analyse_B)

#Generate colData, include mitochondrial phylogeny data
#AR104=11a
#AR111=7c
#AR112=7c
#AR114=7c
#AR118=9b
#AR28=?
#AR3=10c
#AR43=8b

sample    <- gsub(x = colnames(to_analyse_DESeq2_ar), pattern = "(.+)(_[Bb])", replacement = "\\1")
allele    <- gsub(x = colnames(to_analyse_DESeq2_ar), pattern = "(.+_)([Bb])", replacement = "\\2")
body_part <- gsub(x = sample, pattern = "([0-9]+[BC]?Q?)([A-Z])", replacement = "\\2")
individual <- gsub(x = sample, pattern = "([0-9]+[BC]?[QW])([A-Z])", replacement = "\\1")
colony <- gsub(x = sample, pattern = "([0-9]+)([A-Z]+)", replacement = paste0("AR", "\\1"), perl = TRUE)
colData_ar <- data.frame(sample, allele, body_part, colony, individual)
rownames(colData_ar) <- colnames(to_analyse_DESeq2_ar)

#Make sure the all the data are integers
to_analyse_DESeq2_ar <- round(to_analyse_DESeq2_ar)
```

##DESeq2 analysis

The analysis for the allele specific expression between the SB and Sb variants is performed in DESeq2. Because the variant specific counts that are being compared always come from the same sample (and therefore, the same library), performing normalisation would flatten actual differences. The analysis therefore needs to be performed ensuring that the samples are not normalised (more info here<http://rpubs.com/mikelove/ase>). The first analysis will consider 'colony', 'body_part', 'allele' and the interaction between 'allele:body_part'.

``` {r interaction_allele:body_part, message = FALSE}
#Get the data into DESeq2, get size factors by body part only (or sample?)

dds_ar_interaction <- DESeqDataSetFromMatrix(countData = to_analyse_DESeq2_ar, colData = colData_ar, design = ~ colony + body_part + allele + allele:body_part)
#Perform the analysis replacing the sizeFactors: 
sizeFactors(dds_ar_interaction) <- rep(1, ncol(to_analyse_DESeq2_ar))
#If using test = LRT, deseq2 performs a test for detecting DE loci, using first a likelihood ratio test (ANOVA-like). This test compares the model ~body_part+allele against a
#reduced model, ~body_part. The p values indicate which genes are significantly DE accross ALL levels of allele. Normalisation
#has been done only by boy_part, as ASE data comes always from the same sample. If test is not specified it runs the usual Wald test for the last element in the design formula (body_part:allele)
dds_deg_ar_interaction <- DESeq(dds_ar_interaction, test = "LRT", reduced = ~ colony + body_part + allele)

#Get results
res_deg_ar_interaction <- results(dds_deg_all_interaction)
#How many DEG with interaction?
length(which(res_deg_ar_interaction$padj < 0.05))
#0
```
The interaction effect by body part is non-significant for ANY genes in the supergene. Next model, WITHOUT interaction term, just looking directly at 
the allele effect once the body part and colony effect have been considered

``` {r interaction_allele:body_part, message = FALSE}
dds_ar <- DESeqDataSetFromMatrix(countData = to_analyse_DESeq2_ar, colData = colData_ar, design = ~ colony + body_part + allele)
#Perform the analysis replacing the sizeFactors: 
sizeFactors(dds_ar) <- rep(1, ncol(to_analyse_DESeq2_ar))
#Perform DESeq analysis
dds_deg_ar <- DESeq(dds_ar)

#Get results
res_deg_ar <- results(dds_deg_ar)

#Create a 'transparent' black color:
trans_black <- adjustcolor("black", alpha.f = 0.2)

par(mar = c(5, 4.6, 4, 2) + 0.1, mfrow = c(1,1))
plotMA(res_deg_ar, alpha = 0.05,  ylim= c(-8, 8), xlab = "Mean of normalized counts", colNonSig = trans_black,
       ylab = "Logarithm Fold Change", font.lab = 2, cex.axis = 2, cex.lab = 2, cex.main = 2.5, cex = 1.5)
```

##Enrichment analyses

Is there a biase towards SB? To check for this, we should expect the median of the ASE LFCs to be significantly positive. THat, is to find more highly expressed genes in SB than in Sb in general.

```{r median_test, message = FALSE}
median(res_deg_ar$log2FoldChange)
wilcox.test(res_deg_ar$log2FoldChange)
```

Additional tests to check for enrichment: Binomial test for significantly DE genes, and chi squared tests for DE genes in SB and Sb.

```{r enrichment_tests, message = FALSE}
#How many DE genes in total?
de_ase_ar <- length(which(res_deg_ar$padj < 0.05))
#8

#How many in each variant?
de_ase_ar_lb <- length(which(res_deg_ar$padj < 0.05 & res_deg_ar$log2FoldChange < 0))
#3
de_ase_ar_bb <- length(which(res_deg_ar$padj < 0.05 & res_deg_ar$log2FoldChange > 0))
#5

#Total genes in the supergene region:


#Chi2 to check wether any of the variants in enriched

to_test_chi           <- matrix(c(de_ase_ar_lb, de_ase_ar - de_ase_ar_lb, de_ase_ar_bb,
                                  de_ase_ar - de_ase_ar_bb), nrow = 2, ncol = 2)
colnames(to_test_chi) <- c("Bb", "BB")
rownames(to_test_chi) <- c("Over-expresed", "Non-DE")

chisq.test(to_test_chi)
```

##Variant specific vs body part comparisons

Different body parts will perform different functions, and this is reflected in gene expression differences. If most genes in the supergene region perform different functions related to social form, the expectation would be that the SB to Sb differences across body parts should change, as we would expect tissues in the head to be performing differently to those in the abdomen. We already know that there is no Sb-Sb, body part interaction from the previous test, but plotting the SB-Sb differences across tissues will help visualise this result.

``` {r plot_allele:body_part_interaction, message = FALSE}
#Get coefficients for interactions only
dds_ar_coef <- DESeqDataSetFromMatrix(countData = to_analyse_DESeq2_ar, colData = colData_ar, design = ~ colony + body_part + allele:body_part)
#Perform the analysis replacing the sizeFactors: 
sizeFactors(dds_ar_coef) <- rep(1, ncol(to_analyse_DESeq2_ar))
dds_deg_ar_coef <- DESeq(dds_ar_coef)
res_deg_ar_coef <- results(dds_deg_ar_coef)

coef_QA <- coefficients(dds_deg_ar_coef)[, "body_partA.alleleB"]
coef_QT <- coefficients(dds_deg_ar_coef)[, "body_partT.alleleB"]
coef_QH <- coefficients(dds_deg_ar_coef)[, "body_partH.alleleB"]
coef_W  <- coefficients(dds_deg_ar_coef)[, "body_partW.alleleB"]

#Plot weihting points by read count mean, add line with linear regression, weighted by counts
#Weight for the point size, by log(mean counts per gene), scaled up to fit 0-1 range
cex_weights <- (log(res_deg_ar_coef$baseMean) - min(log(res_deg_ar_coef$baseMean)))/
  (max(log(res_deg_ar_coef$baseMean))-min(log(res_deg_ar_coef$baseMean)))
par(mfrow = c(3, 2), cex.lab = 2, cex.axis = 2)
plot(coef_QA, coef_QT, type = "n", xlab = "Queen Abdomen LFCs", ylab = "Queen Thorax LFCs")
points(coef_QA, coef_QT, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_QT ~ coef_QA, weights = res_deg_ar_coef$baseMean), col = "red")

plot(coef_QA, coef_QH, type = "n", xlab = "Queen Abdomen LFCs", ylab = "Queen Head LFCs")
points(coef_QA, coef_QH, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_QH ~ coef_QA, weights = res_deg_ar_coef$baseMean), col = "red")

plot(coef_QA, coef_W, type = "n", xlab = "Queen Abdomen LFCs", ylab = "Worker LFCs")
points(coef_QA, coef_W, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_W ~ coef_QA, weights = res_deg_ar_coef$baseMean), col = "red")

plot(coef_QH, coef_W, type = "n", xlab = "Queen Head LFCs", ylab = "Worker LFCs")
points(coef_QH, coef_W, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_W ~ coef_QH, weights = res_deg_ar_coef$baseMean), col = "red")

plot(coef_QT, coef_W, type = "n", xlab = "Queen Thorax LFCs", ylab = "Worker LFCs")
points(coef_QT, coef_W, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_W ~ coef_QT, weights = res_deg_ar_coef$baseMean), col = "red")

plot(coef_QT, coef_QH, type = "n", xlab = "Queen Thorax LFCs", ylab = "Queen Head LFCs")
points(coef_QT, coef_QA, cex = 2*cex_weights, pch = 20)
abline(0,1)
abline(lm(coef_QA ~ coef_QT, weights = res_deg_ar_coef$baseMean), col = "red")
par(mfrow = c(1,1))
```



